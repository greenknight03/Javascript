<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    <script>
        // 참고자료 : https://hanamon.kr/javascript-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%EC%9D%B4%EB%9E%80-hoisting/
        // JS의 모든 선언은 호이스팅(선언이 먼저 메모리에 저장)이 일어납니다.
        // 그러나 let, const, class 이용한 선언문은 호이스팅이 되었지만 안된 것처럼 동작
        // 이러한 현상은 일시적 사각지대(Temporal Dead Zone)에 빠지기 때문
        // 중요한 포인트는 그렇다하여 호이스팅이 안된 것은 아니라는 것!
        // 오류가 나는 이유는 var 키워드는 선언과 함께 undefined로 초기화
        // let과 const는 초기화 되지 않는 상태로 선언만 메모리 저장
        console.log(add1(10, 20)); // 30
        console.log(add2(10, 20)); // 30
        console.log(mul1) // undefined
        // console.log(mul1(10, 20)); // not a function
        // console.log(mul2); // Cannot access 'mul2' before initialization
        // console.log(mul2(10, 20)); // 위와 같은 애러
        // console.log(mul3) // mul3 is not defined, 호이스팅이 안되었기 때문

        // function add1(x, y) {
        //     return x + y;
        // }

        // function add2(x, y) {
        //     return x + y;
        // }


        // var mul1 = function (a, b) {
        //     return a * b;
        // }

        // let mul2 = function (a, b) {
        //     return a * b;
        // }

        // filter함수
        // // https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
        // // mdn 예제
        // const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
        // const result = words.filter(word => word.length > 6);
        // console.log(result);

        let x = [2, 6, 5, 4, 8, 5, 4, 3, 2, 9]
        x.filter(z => z > 5);

        
    </script>
</body>
</html>


<!-- 
  재귀함수 
  팩토리얼, 문자열뒤집기, 피보나치
  factorial, reverse, fib 

function factorial(n){
    if(n <= 1) {
        return n
    }
    return n * factorial(n-1)
}

// factorial(5) == 5 * factorial(4) == 5 * 24
// factorial(4) == 4 * factorial(3) == 4 * 6
// factorial(3) == 3 * factorial(2) == 3 * 2
// factorial(2) == 2 * factorial(1) == 2 * 1
// factorial(1) == 1

------

function reverse(text) {
    text += ''
    if(text.length <= 1) {
        return text
    }
    return reverse(text.slice(1)) + text[0]
}

// reverse(‘hello’) == reverse (‘ello’) + ‘h’ == ‘olle’ + ‘h’
// reverse(‘ello’) == reverse (‘llo’) + ‘e’ == ‘oll’ + ‘e’
// reverse(‘llo’) == reverse (‘lo’) + ‘l’ == ‘ol’ + ‘l’
// reverse(‘lo’) == reverse (‘o’) + ‘l’ == ‘o’ + ‘l’
// reverse(‘o’) == ‘o’

-------

피보나치 수열

 // 1, 1, 2, 3, 5, 8, 13, 21

function fib(n){
    if(n <= 2) {
        return n
    }
    return fib(n-1) + fib(n-2)
}

// 왼쪽 function만 따라갔으니
// fib(4) == fib(3) + fib(2)
// fib(3) == fib(2) + fib(1) == 3
// fib(2) == 2
// fib(1) == 1

// 오른쪽 값인 fib(2)를 다시 해야하는 상황!!
// fib(2) == 2
  
  -->
  
  
  
<!-- let data = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
undefined
let newData = data.map(a => a.map(n => n *2));


@forEach에서 s가 없으면 콜백함수를 안쓴건가요??

@ y => s+=y가 콜백함수입니다

@ 콜백함수라는게 이름으로 받아서 나중에 실행시켜줄 함수 라고 아까 정리했는데 .. 음.. 그냥 forEach 안에 들어가는 함수 자체를 콜백함수라고 보면 되겠죠??

@ y => s+=y는 이름이 없으니까 익명함수가 들어간 것으로 보시면 됩니다. (화살표 함수는 항상 익명함수입니다)
forEach처럼 함수의 매개변수로 함수를 받게 되면 그때 괄호 안에 들어가는 함수가 콜백함수입니다.

지영님 말씀처럼 이름으로 받아도 됩니다.
function getScore(x) { return x.중간고사점수; }
function sumScore(y) { s += y; }
data.map(getScore).forEach(sumScore);

이게 이름으로 받는 방법이고요

data.map(x => x.중간고사점수).forEach(y => s+=y)

호준님 코드는 화살표함수(익명함수)를 그대로 안에 집어넣은 것입니다.
왜냐하면 코드가 길지 않아서 함수를 따로 정의하는 것보다 이게 더 편하기 때문입니다.

화살표 함수가 아니라 일반 익명함수를 콜백함수에 직접 넣을 수도 있습니다.
data.map(function (x) { return x.중간고사점수; }).forEach(function (y) { s += y; });


굳이 이렇게 할 필요는 없지만 이름이 있는 함수도 직접 넣어도 됩니다.
data.map(function getScore(x) { return x.중간고사점수; }).forEach(function sumScore(y) { s += y; }); -->


